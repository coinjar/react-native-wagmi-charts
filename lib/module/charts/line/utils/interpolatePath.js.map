{"version":3,"sources":["interpolatePath.ts"],"names":["decasteljau","points","t","left","right","decasteljauRecurse","length","push","newPoints","Array","i","reverse","pointsToCommand","command","x2","y2","x1","y1","x","y","type","splitCurveAsPoints","segmentCount","segments","remainingCurve","tIncrement","tRelative","split","splitCurve","commandStart","commandEnd","map","typeMap","M","L","H","V","C","S","Q","T","A","Z","Object","keys","forEach","key","toLowerCase","arrayOfLength","value","array","commandToString","p","join","convertToSameType","aCommand","bCommand","conversionMap","readFromBKeys","toUpperCase","aConverted","bKey","bValue","aValue","undefined","includes","splitSegment","concat","copyCommand","assign","extend","commandsToExtend","referenceCommands","excludeSegment","numSegmentsToExtend","numReferenceSegments","segmentRatio","countPointsPerSegment","reduce","accum","d","insertIndex","Math","floor","addToPriorSegment","extended","lastCommandCopies","unshift","pathCommandsFromString","tokens","match","commands","commandArgs","a","interpolatePathCommands","aCommandsInput","bCommandsInput","aCommands","slice","bCommands","nullInterpolator","addZ","pop","numPointsToExtend","abs","interpolatedCommands","pathCommandInterpolator","interpolatedCommand","j","arg","round","interpolatePath","b","commandInterpolator","pathStringInterpolator","interpolatedString"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n/**\n * Reanimated compatible fork of https://github.com/pbeshai/d3-interpolate-path\n */\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////\n\n/**\n * de Casteljau's algorithm for drawing and splitting bezier curves.\n * Inspired by https://pomax.github.io/bezierinfo/\n *\n * @param {Number[][]} points Array of [x,y] points: [start, control1, control2, ..., end]\n *   The original segment to split.\n * @param {Number} t Where to split the curve (value between [0, 1])\n * @return {Object} An object { left, right } where left is the segment from 0..t and\n *   right is the segment from t..1.\n */\nfunction decasteljau(points, t) {\n  'worklet';\n\n  const left = [];\n  const right = [];\n\n  function decasteljauRecurse(points, t) {\n    'worklet';\n\n    if (points.length === 1) {\n      left.push(points[0]);\n      right.push(points[0]);\n    } else {\n      const newPoints = Array(points.length - 1);\n\n      for (let i = 0; i < newPoints.length; i++) {\n        if (i === 0) {\n          left.push(points[0]);\n        }\n        if (i === newPoints.length - 1) {\n          right.push(points[i + 1]);\n        }\n\n        newPoints[i] = [\n          (1 - t) * points[i][0] + t * points[i + 1][0],\n          (1 - t) * points[i][1] + t * points[i + 1][1],\n        ];\n      }\n\n      decasteljauRecurse(newPoints, t);\n    }\n  }\n\n  if (points.length) {\n    decasteljauRecurse(points, t);\n  }\n\n  return { left, right: right.reverse() };\n}\n\n/**\n * Convert segments represented as points back into a command object\n *\n * @param {Number[][]} points Array of [x,y] points: [start, control1, control2, ..., end]\n *   Represents a segment\n * @return {Object} A command object representing the segment.\n */\nfunction pointsToCommand(points) {\n  'worklet';\n\n  const command = {};\n\n  if (points.length === 4) {\n    command.x2 = points[2][0];\n    command.y2 = points[2][1];\n  }\n  if (points.length >= 3) {\n    command.x1 = points[1][0];\n    command.y1 = points[1][1];\n  }\n\n  command.x = points[points.length - 1][0];\n  command.y = points[points.length - 1][1];\n\n  if (points.length === 4) {\n    // start, control1, control2, end\n    command.type = 'C';\n  } else if (points.length === 3) {\n    // start, control, end\n    command.type = 'Q';\n  } else {\n    // start, end\n    command.type = 'L';\n  }\n\n  return command;\n}\n\n/**\n * Runs de Casteljau's algorithm enough times to produce the desired number of segments.\n *\n * @param {Number[][]} points Array of [x,y] points for de Casteljau (the initial segment to split)\n * @param {Number} segmentCount Number of segments to split the original into\n * @return {Number[][][]} Array of segments\n */\nfunction splitCurveAsPoints(points, segmentCount) {\n  'worklet';\n\n  segmentCount = segmentCount || 2;\n\n  const segments = [];\n  let remainingCurve = points;\n  const tIncrement = 1 / segmentCount;\n\n  // x-----x-----x-----x\n  // t=  0.33   0.66   1\n  // x-----o-----------x\n  // r=  0.33\n  //       x-----o-----x\n  // r=         0.5  (0.33 / (1 - 0.33))  === tIncrement / (1 - (tIncrement * (i - 1))\n\n  // x-----x-----x-----x----x\n  // t=  0.25   0.5   0.75  1\n  // x-----o----------------x\n  // r=  0.25\n  //       x-----o----------x\n  // r=         0.33  (0.25 / (1 - 0.25))\n  //             x-----o----x\n  // r=         0.5  (0.25 / (1 - 0.5))\n\n  for (let i = 0; i < segmentCount - 1; i++) {\n    const tRelative = tIncrement / (1 - tIncrement * i);\n    const split = decasteljau(remainingCurve, tRelative);\n    segments.push(split.left);\n    remainingCurve = split.right;\n  }\n\n  // last segment is just to the end from the last point\n  segments.push(remainingCurve);\n\n  return segments;\n}\n\n/**\n * Convert command objects to arrays of points, run de Casteljau's algorithm on it\n * to split into to the desired number of segments.\n *\n * @param {Object} commandStart The start command object\n * @param {Object} commandEnd The end command object\n * @param {Number} segmentCount The number of segments to create\n * @return {Object[]} An array of commands representing the segments in sequence\n */\nexport function splitCurve(commandStart, commandEnd, segmentCount) {\n  'worklet';\n\n  const points = [[commandStart.x, commandStart.y]];\n  if (commandEnd.x1 != null) {\n    points.push([commandEnd.x1, commandEnd.y1]);\n  }\n  if (commandEnd.x2 != null) {\n    points.push([commandEnd.x2, commandEnd.y2]);\n  }\n  points.push([commandEnd.x, commandEnd.y]);\n\n  return splitCurveAsPoints(points, segmentCount).map(pointsToCommand);\n}\n\n/**\n * List of params for each command type in a path `d` attribute\n */\nconst typeMap = {\n  M: ['x', 'y'],\n  L: ['x', 'y'],\n  H: ['x'],\n  V: ['y'],\n  C: ['x1', 'y1', 'x2', 'y2', 'x', 'y'],\n  S: ['x2', 'y2', 'x', 'y'],\n  Q: ['x1', 'y1', 'x', 'y'],\n  T: ['x', 'y'],\n  A: ['rx', 'ry', 'xAxisRotation', 'largeArcFlag', 'sweepFlag', 'x', 'y'],\n  Z: [],\n};\n\n// Add lower case entries too matching uppercase (e.g. 'm' == 'M')\nObject.keys(typeMap).forEach((key) => {\n  typeMap[key.toLowerCase()] = typeMap[key];\n});\n\nfunction arrayOfLength(length, value) {\n  'worklet';\n\n  const array = Array(length);\n  for (let i = 0; i < length; i++) {\n    array[i] = value;\n  }\n\n  return array;\n}\n\n/**\n * Converts a command object to a string to be used in a `d` attribute\n * @param {Object} command A command object\n * @return {String} The string for the `d` attribute\n */\nfunction commandToString(command) {\n  'worklet';\n\n  return `${command.type}${typeMap[command.type]\n    .map((p) => command[p])\n    .join(',')}`;\n}\n\n/**\n * Converts command A to have the same type as command B.\n *\n * e.g., L0,5 -> C0,5,0,5,0,5\n *\n * Uses these rules:\n * x1 <- x\n * x2 <- x\n * y1 <- y\n * y2 <- y\n * rx <- 0\n * ry <- 0\n * xAxisRotation <- read from B\n * largeArcFlag <- read from B\n * sweepflag <- read from B\n *\n * @param {Object} aCommand Command object from path `d` attribute\n * @param {Object} bCommand Command object from path `d` attribute to match against\n * @return {Object} aCommand converted to type of bCommand\n */\nfunction convertToSameType(aCommand, bCommand) {\n  'worklet';\n\n  const conversionMap = {\n    x1: 'x',\n    y1: 'y',\n    x2: 'x',\n    y2: 'y',\n  };\n\n  const readFromBKeys = ['xAxisRotation', 'largeArcFlag', 'sweepFlag'];\n\n  // convert (but ignore M types)\n  if (aCommand.type !== bCommand.type && bCommand.type.toUpperCase() !== 'M') {\n    const aConverted = {};\n    Object.keys(bCommand).forEach((bKey) => {\n      const bValue = bCommand[bKey];\n      // first read from the A command\n      let aValue = aCommand[bKey];\n\n      // if it is one of these values, read from B no matter what\n      if (aValue === undefined) {\n        if (readFromBKeys.includes(bKey)) {\n          aValue = bValue;\n        } else {\n          // if it wasn't in the A command, see if an equivalent was\n          if (aValue === undefined && conversionMap[bKey]) {\n            aValue = aCommand[conversionMap[bKey]];\n          }\n\n          // if it doesn't have a converted value, use 0\n          if (aValue === undefined) {\n            aValue = 0;\n          }\n        }\n      }\n\n      aConverted[bKey] = aValue;\n    });\n\n    // update the type to match B\n    aConverted.type = bCommand.type;\n    aCommand = aConverted;\n  }\n\n  return aCommand;\n}\n\n/**\n * Interpolate between command objects commandStart and commandEnd segmentCount times.\n * If the types are L, Q, or C then the curves are split as per de Casteljau's algorithm.\n * Otherwise we just copy commandStart segmentCount - 1 times, finally ending with commandEnd.\n *\n * @param {Object} commandStart Command object at the beginning of the segment\n * @param {Object} commandEnd Command object at the end of the segment\n * @param {Number} segmentCount The number of segments to split this into. If only 1\n *   Then [commandEnd] is returned.\n * @return {Object[]} Array of ~segmentCount command objects between commandStart and\n *   commandEnd. (Can be segmentCount+1 objects if commandStart is type M).\n */\nfunction splitSegment(commandStart, commandEnd, segmentCount) {\n  'worklet';\n\n  let segments = [];\n\n  // line, quadratic bezier, or cubic bezier\n  if (\n    commandEnd.type === 'L' ||\n    commandEnd.type === 'Q' ||\n    commandEnd.type === 'C'\n  ) {\n    segments = segments.concat(\n      splitCurve(commandStart, commandEnd, segmentCount)\n    );\n\n    // general case - just copy the same point\n  } else {\n    const copyCommand = Object.assign({}, commandStart);\n\n    // convert M to L\n    if (copyCommand.type === 'M') {\n      copyCommand.type = 'L';\n    }\n\n    segments = segments.concat(\n      arrayOfLength(segmentCount - 1).map(() => copyCommand)\n    );\n    segments.push(commandEnd);\n  }\n\n  return segments;\n}\n/**\n * Extends an array of commandsToExtend to the length of the referenceCommands by\n * splitting segments until the number of commands match. Ensures all the actual\n * points of commandsToExtend are in the extended array.\n *\n * @param {Object[]} commandsToExtend The command object array to extend\n * @param {Object[]} referenceCommands The command object array to match in length\n * @param {Function} excludeSegment a function that takes a start command object and\n *   end command object and returns true if the segment should be excluded from splitting.\n * @return {Object[]} The extended commandsToExtend array\n */\nfunction extend(commandsToExtend, referenceCommands, excludeSegment) {\n  'worklet';\n\n  // compute insertion points:\n  // number of segments in the path to extend\n  const numSegmentsToExtend = commandsToExtend.length - 1;\n\n  // number of segments in the reference path.\n  const numReferenceSegments = referenceCommands.length - 1;\n\n  // this value is always between [0, 1].\n  const segmentRatio = numSegmentsToExtend / numReferenceSegments;\n\n  // create a map, mapping segments in referenceCommands to how many points\n  // should be added in that segment (should always be >= 1 since we need each\n  // point itself).\n  // 0 = segment 0-1, 1 = segment 1-2, n-1 = last vertex\n  const countPointsPerSegment = arrayOfLength(numReferenceSegments).reduce(\n    (accum, d, i) => {\n      let insertIndex = Math.floor(segmentRatio * i);\n\n      // handle excluding segments\n      if (\n        excludeSegment &&\n        insertIndex < commandsToExtend.length - 1 &&\n        excludeSegment(\n          commandsToExtend[insertIndex],\n          commandsToExtend[insertIndex + 1]\n        )\n      ) {\n        // set the insertIndex to the segment that this point should be added to:\n\n        // round the insertIndex essentially so we split half and half on\n        // neighbouring segments. hence the segmentRatio * i < 0.5\n        const addToPriorSegment = (segmentRatio * i) % 1 < 0.5;\n\n        // only skip segment if we already have 1 point in it (can't entirely remove a segment)\n        if (accum[insertIndex]) {\n          // TODO - Note this is a naive algorithm that should work for most d3-area use cases\n          // but if two adjacent segments are supposed to be skipped, this will not perform as\n          // expected. Could be updated to search for nearest segment to place the point in, but\n          // will only do that if necessary.\n\n          // add to the prior segment\n          if (addToPriorSegment) {\n            if (insertIndex > 0) {\n              insertIndex -= 1;\n\n              // not possible to add to previous so adding to next\n            } else if (insertIndex < commandsToExtend.length - 1) {\n              insertIndex += 1;\n            }\n            // add to next segment\n          } else if (insertIndex < commandsToExtend.length - 1) {\n            insertIndex += 1;\n\n            // not possible to add to next so adding to previous\n          } else if (insertIndex > 0) {\n            insertIndex -= 1;\n          }\n        }\n      }\n\n      accum[insertIndex] = (accum[insertIndex] || 0) + 1;\n\n      return accum;\n    },\n    []\n  );\n\n  // extend each segment to have the correct number of points for a smooth interpolation\n  const extended = countPointsPerSegment.reduce((extended, segmentCount, i) => {\n    // if last command, just add `segmentCount` number of times\n    if (i === commandsToExtend.length - 1) {\n      const lastCommandCopies = arrayOfLength(\n        segmentCount,\n        Object.assign({}, commandsToExtend[commandsToExtend.length - 1])\n      );\n\n      // convert M to L\n      if (lastCommandCopies[0].type === 'M') {\n        lastCommandCopies.forEach((d) => {\n          d.type = 'L';\n        });\n      }\n      return extended.concat(lastCommandCopies);\n    }\n\n    // otherwise, split the segment segmentCount times.\n    return extended.concat(\n      splitSegment(commandsToExtend[i], commandsToExtend[i + 1], segmentCount)\n    );\n  }, []);\n\n  // add in the very first point since splitSegment only adds in the ones after it\n  extended.unshift(commandsToExtend[0]);\n\n  return extended;\n}\n\n/**\n * Takes a path `d` string and converts it into an array of command\n * objects. Drops the `Z` character.\n *\n * @param {String|null} d A path `d` string\n */\nexport function pathCommandsFromString(d) {\n  'worklet';\n\n  // split into valid tokens\n  const tokens = (d || '').match(/[MLCSTQAHVZmlcstqahv]|-?[\\d.e+-]+/g) || [];\n  const commands = [];\n  let commandArgs;\n  let command;\n\n  // iterate over each token, checking if we are at a new command\n  // by presence in the typeMap\n  for (let i = 0; i < tokens.length; ++i) {\n    commandArgs = typeMap[tokens[i]];\n\n    // new command found:\n    if (commandArgs) {\n      command = {\n        type: tokens[i],\n      };\n\n      // add each of the expected args for this command:\n      for (let a = 0; a < commandArgs.length; ++a) {\n        command[commandArgs[a]] = +tokens[i + a + 1];\n      }\n\n      // need to increment our token index appropriately since\n      // we consumed token args\n      i += commandArgs.length;\n\n      commands.push(command);\n    }\n  }\n  return commands;\n}\n\n/**\n * Interpolate from A to B by extending A and B during interpolation to have\n * the same number of points. This allows for a smooth transition when they\n * have a different number of points.\n *\n * Ignores the `Z` command in paths unless both A and B end with it.\n *\n * This function works directly with arrays of command objects instead of with\n * path `d` strings (see interpolatePath for working with `d` strings).\n *\n * @param {Object[]} aCommandsInput Array of path commands\n * @param {Object[]} bCommandsInput Array of path commands\n * @param {Function} excludeSegment a function that takes a start command object and\n *   end command object and returns true if the segment should be excluded from splitting.\n * @returns {Function} Interpolation function that maps t ([0, 1]) to an array of path commands.\n */\nexport function interpolatePathCommands(\n  aCommandsInput,\n  bCommandsInput,\n  excludeSegment\n) {\n  'worklet';\n\n  // make a copy so we don't mess with the input arrays\n  let aCommands = aCommandsInput == null ? [] : aCommandsInput.slice();\n  let bCommands = bCommandsInput == null ? [] : bCommandsInput.slice();\n\n  // both input sets are empty, so we don't interpolate\n  if (!aCommands.length && !bCommands.length) {\n    return function nullInterpolator() {\n      'worklet';\n\n      return [];\n    };\n  }\n\n  // do we add Z during interpolation? yes if both have it. (we'd expect both to have it or not)\n  const addZ =\n    (aCommands.length === 0 || aCommands[aCommands.length - 1].type === 'Z') &&\n    (bCommands.length === 0 || bCommands[bCommands.length - 1].type === 'Z');\n\n  // we temporarily remove Z\n  if (aCommands.length > 0 && aCommands[aCommands.length - 1].type === 'Z') {\n    aCommands.pop();\n  }\n  if (bCommands.length > 0 && bCommands[bCommands.length - 1].type === 'Z') {\n    bCommands.pop();\n  }\n\n  // if A is empty, treat it as if it used to contain just the first point\n  // of B. This makes it so the line extends out of from that first point.\n  if (!aCommands.length) {\n    aCommands.push(bCommands[0]);\n\n    // otherwise if B is empty, treat it as if it contains the first point\n    // of A. This makes it so the line retracts into the first point.\n  } else if (!bCommands.length) {\n    bCommands.push(aCommands[0]);\n  }\n\n  // extend to match equal size\n  const numPointsToExtend = Math.abs(bCommands.length - aCommands.length);\n\n  if (numPointsToExtend !== 0) {\n    // B has more points than A, so add points to A before interpolating\n    if (bCommands.length > aCommands.length) {\n      aCommands = extend(aCommands, bCommands, excludeSegment);\n\n      // else if A has more points than B, add more points to B\n    } else if (bCommands.length < aCommands.length) {\n      bCommands = extend(bCommands, aCommands, excludeSegment);\n    }\n  }\n\n  // commands have same length now.\n  // convert commands in A to the same type as those in B\n  aCommands = aCommands.map((aCommand, i) =>\n    convertToSameType(aCommand, bCommands[i])\n  );\n\n  // create mutable interpolated command objects\n  const interpolatedCommands = aCommands.map((aCommand) => aCommand);\n\n  if (addZ) {\n    interpolatedCommands.push({ type: 'Z' });\n    aCommands.push({ type: 'Z' }); // required for when returning at t == 0\n  }\n\n  return function pathCommandInterpolator(t) {\n    'worklet';\n\n    // at 1 return the final value without the extensions used during interpolation\n    if (t === 1) {\n      return bCommandsInput == null ? [] : bCommandsInput;\n    }\n\n    // work with aCommands directly since interpolatedCommands are mutated\n    if (t === 0) {\n      return aCommands;\n    }\n\n    // interpolate the commands using the mutable interpolated command objs\n    for (let i = 0; i < interpolatedCommands.length; ++i) {\n      // if (interpolatedCommands[i].type === 'Z') continue;\n\n      const aCommand = aCommands[i];\n      const bCommand = bCommands[i];\n      const interpolatedCommand = interpolatedCommands[i];\n      for (let j = 0; j < typeMap[interpolatedCommand.type].length; j++) {\n        const arg = typeMap[interpolatedCommand.type][j];\n        interpolatedCommand[arg] = (1 - t) * aCommand[arg] + t * bCommand[arg];\n\n        // do not use floats for flags (#27), round to integer\n        if (arg === 'largeArcFlag' || arg === 'sweepFlag') {\n          interpolatedCommand[arg] = Math.round(interpolatedCommand[arg]);\n        }\n      }\n    }\n\n    return interpolatedCommands;\n  };\n}\n\n/**\n * Interpolate from A to B by extending A and B during interpolation to have\n * the same number of points. This allows for a smooth transition when they\n * have a different number of points.\n *\n * Ignores the `Z` character in paths unless both A and B end with it.\n *\n * @param {String} a The `d` attribute for a path\n * @param {String} b The `d` attribute for a path\n * @param {Function} excludeSegment a function that takes a start command object and\n *   end command object and returns true if the segment should be excluded from splitting.\n * @returns {Function} Interpolation function that maps t ([0, 1]) to a path `d` string.\n */\nexport function interpolatePath(a, b, excludeSegment) {\n  'worklet';\n\n  let aCommands = pathCommandsFromString(a);\n  let bCommands = pathCommandsFromString(b);\n\n  if (!aCommands.length && !bCommands.length) {\n    return function nullInterpolator() {\n      'worklet';\n\n      return '';\n    };\n  }\n\n  const commandInterpolator = interpolatePathCommands(\n    aCommands,\n    bCommands,\n    excludeSegment\n  );\n\n  return function pathStringInterpolator(t) {\n    'worklet';\n\n    // at 1 return the final value without the extensions used during interpolation\n    if (t === 1) {\n      return b == null ? '' : b;\n    }\n\n    const interpolatedCommands = commandInterpolator(t);\n\n    // convert to a string (fastest concat: https://jsperf.com/join-concat/150)\n    let interpolatedString = '';\n    for (let i = 0; i < interpolatedCommands.length; i++) {\n      const interpolatedCommand = interpolatedCommands[i];\n      interpolatedString += commandToString(interpolatedCommand);\n    }\n\n    return interpolatedString;\n  };\n}\n"]}